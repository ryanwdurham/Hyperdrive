<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HYPER DRIVE: NEON HIGHWAY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
        }
        
        canvas {
            display: block;
            image-rendering: optimizeSpeed;
        }
        
        /* UI Controls - HORIZONTAL on LEFT */
        #controls {
            position: absolute;
            top: 95px;
            left: 20px;
            display: flex;
            flex-direction: row;
            gap: 8px;
            z-index: 150;
        }
        
        .control-btn {
            width: 45px;
            height: 45px;
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid #0ff;
            border-radius: 6px;
            color: #0ff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.3);
        }
        
        .control-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn.active {
            background: rgba(255, 0, 85, 0.3);
            border-color: #f05;
            color: #f05;
        }
        
        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #scorePanel {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
        }
        
        .stat-group {
            text-align: left;
        }
        
        .stat-group.right {
            text-align: right;
        }
        
        .stat-label {
            font-size: 9px;
            letter-spacing: 2px;
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 12px #0ff, 0 0 24px #0ff;
            font-family: 'Audiowide', cursive;
        }
        
        #weaponType {
            color: #f0f;
            text-shadow: 0 0 12px #f0f, 0 0 24px #f0f;
            font-size: 20px;
        }
        
        #health {
            color: #0f0;
            text-shadow: 0 0 12px #0f0, 0 0 24px #0f0;
        }
        
        #coins {
            color: #ff0;
            text-shadow: 0 0 12px #ff0, 0 0 24px #ff0;
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: all;
            display: none;
            z-index: 101;
        }
        
        #mobileControls.active {
            display: flex;
        }
        
        .control-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-move {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.4), rgba(0,255,255,0.1));
            border: 3px solid #0ff;
            box-shadow: 0 0 20px #0ff, inset 0 0 20px rgba(0,255,255,0.2);
            font-size: 36px;
            color: #0ff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            text-shadow: 0 0 10px #0ff;
        }
        
        .btn-fire {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,0,85,0.5), rgba(255,0,85,0.1));
            border: 4px solid #f05;
            box-shadow: 0 0 30px #f05, inset 0 0 30px rgba(255,0,85,0.2);
            font-size: 14px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            text-shadow: 0 0 15px #f05;
            letter-spacing: 2px;
        }
        
        .btn-move:active, .btn-fire:active {
            transform: scale(0.92);
        }
        
        /* Messages */
        #message {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            font-weight: 900;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 102;
            text-align: center;
            font-family: 'Audiowide', cursive;
            white-space: pre-line;
        }
        
        #message.show {
            opacity: 1;
        }
        
        /* Start Screen */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1e 0%, #1a0a2e 50%, #0a0a1e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: all;
        }
        
        #startScreen.hidden {
            display: none;
        }
        
        .game-title {
            font-family: 'Audiowide', cursive;
            font-size: 72px;
            background: linear-gradient(45deg, #0ff, #f0f, #ff0, #0ff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px #0ff;
            margin-bottom: 10px;
            animation: gradientShift 3s ease infinite, pulse 2s ease-in-out infinite;
        }
        
        .game-subtitle {
            font-size: 28px;
            color: #f0f;
            text-shadow: 0 0 15px #f0f, 0 0 30px #f0f;
            margin-bottom: 50px;
            letter-spacing: 12px;
            animation: glow 2s ease-in-out infinite;
        }
        
        .start-btn {
            padding: 22px 70px;
            font-size: 32px;
            font-family: 'Audiowide', cursive;
            background: linear-gradient(135deg, #f05, #f0f, #05f);
            background-size: 200% 200%;
            border: none;
            color: #fff;
            cursor: pointer;
            text-shadow: 0 0 10px #000;
            box-shadow: 0 0 40px #f0f, 0 0 80px #f05;
            border-radius: 12px;
            transition: all 0.3s;
            animation: gradientShift 3s ease infinite;
        }
        
        .start-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 0 60px #f0f, 0 0 120px #f05;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        
        @keyframes glow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .game-title { font-size: 52px; }
            .game-subtitle { font-size: 20px; letter-spacing: 6px; }
            .start-btn { font-size: 26px; padding: 18px 50px; }
            .stat-value { font-size: 22px; }
            #weaponType { font-size: 16px; }
        }
    </style>
</head>
<body>

<canvas id="game"></canvas>

<div id="controls">
    <div class="control-btn" id="pauseBtn">‚è∏</div>
    <div class="control-btn" id="muteBtn">üîä</div>
</div>

<div id="hud">
    <div id="scorePanel">
        <div class="stat-group">
            <div class="stat-label">SCORE</div>
            <div class="stat-value" id="score">000000</div>
        </div>
        <div class="stat-group">
            <div class="stat-label">COINS</div>
            <div class="stat-value" id="coins">0</div>
        </div>
        <div class="stat-group">
            <div class="stat-label">TIME</div>
            <div class="stat-value" id="time">0:00</div>
        </div>
        <div class="stat-group right">
            <div class="stat-label">HEALTH</div>
            <div class="stat-value" id="health">100%</div>
        </div>
        <div class="stat-group right">
            <div class="stat-label">WEAPON</div>
            <div class="stat-value" id="weaponType">BLASTER</div>
        </div>
    </div>
</div>

<div id="mobileControls">
    <div class="control-area">
        <div class="btn-move" id="btnLeft">‚óÑ</div>
    </div>
    <div class="control-area">
        <div class="btn-fire" id="btnFire">FIRE</div>
    </div>
    <div class="control-area">
        <div class="btn-move" id="btnRight">‚ñ∫</div>
    </div>
</div>

<div id="message"></div>

<div id="startScreen">
    <div class="game-title">HYPER DRIVE</div>
    <div class="game-subtitle">NEON HIGHWAY</div>
    <button class="start-btn" id="startBtn">BEGIN MISSION</button>
</div>

<script>
// ============================================================================
// HYPER DRIVE: NEON HIGHWAY - ENHANCED VERSION
// ============================================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
    TARGET_FPS: 60,
    
    PLAYER_SPEED: isMobile ? 9 : 13,
    PLAYER_WIDTH: 45,
    PLAYER_HEIGHT: 70,
    PLAYER_MAX_HEALTH: 100,
    
    ROAD_WIDTH: 0.75,
    LANE_COUNT: 5,
    
    // FASTER PROGRESSION - Reaches max speed by 60-90 seconds
    DIFFICULTY_TIERS: [
        { time: 0, speed: 4, enemyRate: 75, coinRate: 30, obstacleRate: 140, trapRate: 200, aggressiveness: 0, name: "ROOKIE" },
        { time: 20, speed: 6, enemyRate: 55, coinRate: 35, obstacleRate: 110, trapRate: 160, aggressiveness: 0.3, name: "STREET" },
        { time: 40, speed: 9, enemyRate: 38, coinRate: 42, obstacleRate: 85, trapRate: 130, aggressiveness: 0.5, name: "PRO" },
        { time: 60, speed: 13, enemyRate: 28, coinRate: 50, obstacleRate: 65, trapRate: 100, aggressiveness: 0.7, name: "EXPERT" },
        { time: 90, speed: 17, enemyRate: 20, coinRate: 60, obstacleRate: 50, trapRate: 75, aggressiveness: 0.85, name: "MASTER" },
        { time: 120, speed: 22, enemyRate: 15, coinRate: 75, obstacleRate: 40, trapRate: 60, aggressiveness: 1.0, name: "LEGEND" }
    ],
    
    THEMES: [
        { name: "MIDNIGHT CITY", colors: ['#0a0a2e', '#16213e', '#1a1a3e'], accent: '#0ff' },
        { name: "NEON SUNSET", colors: ['#2e0a2e', '#3e1626', '#2e0a1a'], accent: '#f0f' },
        { name: "CYBER GRID", colors: ['#0a2e1a', '#16263e', '#0a1a2e'], accent: '#0f0' },
        { name: "BLADE RUNNER", colors: ['#2e2e0a', '#3e3616', '#2e1a0a'], accent: '#ff0' },
        { name: "RETRO WAVE", colors: ['#2e0a1a', '#1a0a2e', '#0a1a2e'], accent: '#f05' }
    ],
    
    WEAPONS: [
        { name: "BLASTER", color: "#00ffff", fireRate: 120, damage: 1, pattern: "single" },
        { name: "TRIPLE", color: "#00ff00", fireRate: 100, damage: 1, pattern: "triple" },
        { name: "SPREAD", color: "#ff00ff", fireRate: 80, damage: 1, pattern: "spread" },
        { name: "LASER", color: "#ff0000", fireRate: 60, damage: 2, pattern: "laser" },
        { name: "PLASMA", color: "#ffff00", fireRate: 50, damage: 1, pattern: "plasma" }
    ],
    
    BULLET_SPEED: 18,
    
    // 10+ DIVERSE ENEMY TYPES
    ENEMY_TYPES: [
        { name: "SCOUT", size: 32, health: 1, speed: 1.2, points: 80, shootChance: 0, color: '#ff0055', aggressive: true },
        { name: "INTERCEPTOR", size: 38, health: 1, speed: 1.15, points: 100, shootChance: 0.01, color: '#ff3388', aggressive: true },
        { name: "FIGHTER", size: 45, health: 2, speed: 0.95, points: 200, shootChance: 0.018, color: '#ff6600', aggressive: false },
        { name: "GUNSHIP", size: 50, health: 3, speed: 0.85, points: 300, shootChance: 0.025, color: '#ff9900', aggressive: false },
        { name: "ASSAULT", size: 52, health: 3, speed: 0.9, points: 320, shootChance: 0.022, color: '#ffcc00', aggressive: true },
        { name: "TANK", size: 60, health: 5, speed: 0.7, points: 450, shootChance: 0.015, color: '#ff00ff', aggressive: false },
        { name: "HEAVY", size: 65, health: 6, speed: 0.65, points: 500, shootChance: 0.02, color: '#cc00ff', aggressive: false },
        { name: "DREADNOUGHT", size: 75, health: 8, speed: 0.55, points: 700, shootChance: 0.025, color: '#9900ff', aggressive: false },
        { name: "BOSS_ALPHA", size: 90, health: 12, speed: 0.45, points: 1000, shootChance: 0.03, color: '#00ffff', aggressive: true },
        { name: "BOSS_OMEGA", size: 100, health: 15, speed: 0.4, points: 1500, shootChance: 0.035, color: '#0088ff', aggressive: true }
    ],
    
    POWERUP_SPAWN_INTERVAL: 420,
    COIN_VALUE: 10,
    SPAWN_DELAY: 5
};

// ============================================================================
// GAME STATE
// ============================================================================

let gameState = {
    running: false,
    paused: false,
    muted: false,
    frame: 0,
    startTime: 0,
    elapsedTime: 0,
    
    score: 0,
    coins: 0,
    health: CONFIG.PLAYER_MAX_HEALTH,
    weaponIndex: 0,
    
    currentTier: 0,
    currentTheme: 0,
    
    speed: 4,
    aggressiveness: 0,
    
    playerX: 0,
    playerY: 0,
    targetX: 0,
    
    shake: 0,
    
    shieldActive: false,
    shieldTime: 0,
    doublePointsActive: false,
    doublePointsTime: 0,
    
    firing: false,
    lastFireTime: 0,
    moveLeft: false,
    moveRight: false
};

// ============================================================================
// ENTITIES
// ============================================================================

class Entity {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dead = false;
    }
    update() {}
    draw() {}
}

class Bullet extends Entity {
    constructor(x, y, vx = 0, vy = -CONFIG.BULLET_SPEED, weaponIndex = 0) {
        super(x, y);
        this.vx = vx;
        this.vy = vy;
        this.weapon = CONFIG.WEAPONS[weaponIndex];
        this.width = 4;
        this.height = 20;
        this.trail = [];
    }
    
    update() {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 5) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.y < -60 || this.x < -50 || this.x > canvas.width + 50) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.save();
        
        if (this.trail.length > 1) {
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < this.trail.length; i++) {
                const t = this.trail[i];
                const alpha = i / this.trail.length;
                ctx.globalAlpha = alpha * 0.4;
                ctx.fillStyle = this.weapon.color;
                ctx.fillRect(t.x - this.width/2, t.y, this.width, this.height);
            }
            ctx.globalAlpha = 1;
        }
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.weapon.color;
        ctx.fillStyle = this.weapon.color;
        
        if (this.weapon.pattern === 'plasma') {
            const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 8);
            gradient.addColorStop(0, this.weapon.color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
        }
        
        ctx.globalAlpha = 0.6;
        ctx.fillRect(this.x - this.width/2 - 1, this.y + this.height, this.width + 2, 8);
        
        ctx.restore();
    }
}

class EnemyBullet extends Entity {
    constructor(x, y, targetX, targetY) {
        super(x, y);
        const angle = Math.atan2(targetY - y, targetX - x);
        const speed = 8;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.width = 6;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.y > canvas.height + 50 || this.y < -50 || this.x < -50 || this.x > canvas.width + 50) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0055';
        ctx.fillStyle = '#ff0055';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(x, y, typeIndex = 0) {
        super(x, y);
        this.type = CONFIG.ENEMY_TYPES[Math.min(typeIndex, CONFIG.ENEMY_TYPES.length - 1)];
        this.size = this.type.size;
        this.maxHealth = this.type.health;
        this.health = this.maxHealth;
        this.baseSpeed = gameState.speed * this.type.speed;
        this.speed = this.baseSpeed;
        this.color = this.type.color;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;
        this.points = this.type.points;
        this.shootCooldown = 0;
        this.aggressive = this.type.aggressive;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.animFrame = 0;
    }
    
    update() {
        // Aggressive movement towards player
        if (this.aggressive && gameState.aggressiveness > 0) {
            const dx = gameState.playerX - this.x;
            const aggressionForce = gameState.aggressiveness * 0.4;
            this.x += dx * aggressionForce * 0.015;
        }
        
        this.y += this.speed;
        this.rotation += this.rotationSpeed;
        this.pulsePhase += 0.1;
        this.animFrame++;
        
        if (this.type.shootChance > 0 && this.shootCooldown <= 0 && this.y > 50) {
            if (Math.random() < this.type.shootChance) {
                enemyBullets.push(new EnemyBullet(this.x, this.y + this.size/2, gameState.playerX, gameState.playerY));
                this.shootCooldown = 60 + Math.random() * 60;
            }
        }
        this.shootCooldown--;
        
        if (this.y > canvas.height + 100) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        const pulse = Math.sin(this.pulsePhase) * 0.1 + 1;
        ctx.scale(pulse, pulse);
        
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.color;
        
        // Different designs based on enemy type
        if (this.type.name === "SCOUT" || this.type.name === "INTERCEPTOR") {
            // Fast, aggressive drone - arrow shape
            ctx.rotate(this.rotation);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, -this.size/2);
            ctx.lineTo(this.size/3, this.size/4);
            ctx.lineTo(0, this.size/2);
            ctx.lineTo(-this.size/3, this.size/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            // Pulsing core
            const coreSize = 6 + Math.sin(this.animFrame * 0.2) * 2;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (this.type.name === "FIGHTER" || this.type.name === "GUNSHIP") {
            // Fighter jet style
            ctx.rotate(this.rotation * 0.3);
            ctx.fillStyle = this.color;
            
            // Main body
            ctx.fillRect(-this.size/4, -this.size/2, this.size/2, this.size);
            
            // Wings with animation
            const wingFlap = Math.sin(this.animFrame * 0.15) * 3;
            ctx.beginPath();
            ctx.moveTo(-this.size/4, -wingFlap);
            ctx.lineTo(-this.size/1.8, -this.size/3 - wingFlap);
            ctx.lineTo(-this.size/1.8, this.size/3 + wingFlap);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(this.size/4, -wingFlap);
            ctx.lineTo(this.size/1.8, -this.size/3 - wingFlap);
            ctx.lineTo(this.size/1.8, this.size/3 + wingFlap);
            ctx.closePath();
            ctx.fill();
            
            // Outline
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(-this.size/4, -this.size/2, this.size/2, this.size);
            
            // Cockpit with glow
            const cockpitGlow = Math.sin(this.animFrame * 0.1) * 0.2 + 0.6;
            ctx.fillStyle = `rgba(255, 255, 255, ${cockpitGlow})`;
            ctx.fillRect(-this.size/6, -this.size/3, this.size/3, this.size/3);
            
            // Engine trails
            if (this.animFrame % 3 === 0) {
                ctx.fillStyle = '#0ff';
                ctx.fillRect(-this.size/5, this.size/2, this.size/10, 8);
                ctx.fillRect(this.size/10, this.size/2, this.size/10, 8);
            }
            
        } else if (this.type.name === "ASSAULT") {
            // Aggressive assault craft - X-wing style
            ctx.rotate(this.rotation);
            
            // Central body
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/5, -this.size/2, this.size/2.5, this.size);
            
            // Four wings
            const wingAngle = Math.sin(this.animFrame * 0.12) * 0.15;
            for (let i = 0; i < 4; i++) {
                ctx.save();
                ctx.rotate((Math.PI / 2) * i);
                ctx.translate(0, -this.size/3);
                ctx.rotate(wingAngle);
                ctx.fillRect(-this.size/8, 0, this.size/4, this.size/2.5);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2.5;
            ctx.strokeRect(-this.size/5, -this.size/2, this.size/2.5, this.size);
            
            // Glowing weapons
            ctx.fillStyle = '#f00';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f00';
            ctx.fillRect(-this.size/4, -this.size/2.2, 4, 6);
            ctx.fillRect(this.size/5, -this.size/2.2, 4, 6);
            
        } else if (this.type.name === "TANK" || this.type.name === "HEAVY") {
            // Tank - detailed hexagonal design
            ctx.rotate(this.rotation * 0.5);
            
            // Outer hexagon
            ctx.fillStyle = this.color;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = Math.cos(angle) * this.size/2;
                const y = Math.sin(angle) * this.size/2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3.5;
            ctx.stroke();
            
            // Inner rotating hexagon
            ctx.save();
            ctx.rotate(this.animFrame * 0.02);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = Math.cos(angle) * this.size/3;
                const y = Math.sin(angle) * this.size/3;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            
            // Pulsing core
            const coreGlow = Math.sin(this.animFrame * 0.15) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${coreGlow})`;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/5, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (this.type.name === "DREADNOUGHT") {
            // Massive ship - cruiser style
            ctx.rotate(this.rotation * 0.3);
            
            // Main hull
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.size/3, -this.size/2, this.size/1.5, this.size);
            
            // Side sections
            ctx.fillRect(-this.size/2.2, -this.size/3, this.size/8, this.size/1.5);
            ctx.fillRect(this.size/3, -this.size/3, this.size/8, this.size/1.5);
            
            // Outline
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(-this.size/3, -this.size/2, this.size/1.5, this.size);
            
            // Detail lines
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(-this.size/3, i * this.size/6);
                ctx.lineTo(this.size/2.5, i * this.size/6);
                ctx.stroke();
            }
            
            // Glowing engines
            const engineGlow = this.animFrame % 4 < 2;
            ctx.fillStyle = engineGlow ? '#0ff' : '#0aa';
            ctx.fillRect(-this.size/4, this.size/2, this.size/8, 12);
            ctx.fillRect(this.size/12, this.size/2, this.size/8, 12);
            
        } else {
            // BOSS - Ultimate design
            ctx.rotate(this.rotation * 0.2);
            
            // Multi-layered star design
            ctx.fillStyle = this.color;
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                const radius = i % 2 === 0 ? this.size/2 : this.size/2.5;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Rotating inner ring
            ctx.save();
            ctx.rotate(-this.animFrame * 0.03);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            
            // Pulsing core with gradient
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size/4);
            coreGradient.addColorStop(0, '#fff');
            coreGradient.addColorStop(0.5, this.color);
            coreGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/4 + Math.sin(this.animFrame * 0.1) * 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Weapon systems
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i;
                const x = Math.cos(angle) * this.size/2.2;
                const y = Math.sin(angle) * this.size/2.2;
                ctx.fillStyle = '#f00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f00';
                ctx.fillRect(x - 2, y - 2, 4, 4);
            }
        }
        
        ctx.restore();
        
        // Health bar for tough enemies
        if (this.maxHealth > 2) {
            const barWidth = this.size * 1.3;
            const barHeight = 7;
            const barY = this.y - this.size/2 - 20;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
            
            const healthPercent = this.health / this.maxHealth;
            const healthColor = healthPercent > 0.6 ? this.color : (healthPercent > 0.3 ? '#ff6600' : '#ff0055');
            
            const gradient = ctx.createLinearGradient(this.x - barWidth/2, 0, this.x + barWidth/2, 0);
            gradient.addColorStop(0, 'rgba(0,0,0,0.5)');
            gradient.addColorStop(0.5, healthColor);
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(this.x - barWidth/2, barY, barWidth, barHeight);
        }
    }
    
    takeDamage(damage = 1) {
        this.health -= damage;
        if (this.health <= 0) {
            this.dead = true;
            const points = gameState.doublePointsActive ? this.points * 2 : this.points;
            gameState.score += points;
            createExplosion(this.x, this.y, this.color, 30);
            gameState.shake = 6 + this.maxHealth * 2;
        }
    }
}

class Obstacle extends Entity {
    constructor(x, y) {
        super(x, y);
        this.width = 55 + Math.random() * 25;
        this.height = 70 + Math.random() * 35;
        this.speed = gameState.speed;
        this.color = CONFIG.ENEMY_TYPES[Math.floor(Math.random() * 5)].color;
        this.health = 3;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.03;
        this.animFrame = 0;
    }
    
    update() {
        this.y += this.speed;
        this.rotation += this.rotationSpeed;
        this.animFrame++;
        
        if (this.y > canvas.height + 100) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        ctx.shadowBlur = 18;
        ctx.shadowColor = this.color;
        
        // 3D block effect
        const pulse = Math.sin(this.animFrame * 0.08) * 0.05 + 1;
        const w = this.width * pulse;
        const h = this.height * pulse;
        
        // Main face
        const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
        gradient.addColorStop(1, this.color);
        ctx.fillStyle = gradient;
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // Border glow
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3.5;
        ctx.strokeRect(-w/2, -h/2, w, h);
        
        // Inner grid with animation
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        const gridOffset = (this.animFrame * 2) % 20;
        for (let i = -h/2; i < h/2; i += 20) {
            ctx.beginPath();
            ctx.moveTo(-w/2, i + gridOffset);
            ctx.lineTo(w/2, i + gridOffset);
            ctx.stroke();
        }
        for (let i = -w/2; i < w/2; i += 20) {
            ctx.beginPath();
            ctx.moveTo(i + gridOffset, -h/2);
            ctx.lineTo(i + gridOffset, h/2);
            ctx.stroke();
        }
        
        // Warning markers
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (this.animFrame % 30 < 15) {
            ctx.fillText('!', 0, 0);
        }
        
        ctx.restore();
    }
    
    takeDamage(damage = 1) {
        this.health -= damage;
        if (this.health <= 0) {
            this.dead = true;
            gameState.score += 200;
            createExplosion(this.x, this.y, this.color, 25);
            gameState.shake = 12;
        }
    }
}

class Coin extends Entity {
    constructor(x, y) {
        super(x, y);
        this.size = 22;
        this.speed = gameState.speed * 0.7;
        this.rotation = 0;
        this.animFrame = 0;
        this.floatOffset = Math.random() * Math.PI * 2;
    }
    
    update() {
        this.y += this.speed;
        this.rotation += 0.12;
        this.animFrame++;
        
        if (this.y > canvas.height + 100) {
            this.dead = true;
        }
    }
    
    draw() {
        // Floating animation
        const floatY = Math.sin(this.animFrame * 0.1 + this.floatOffset) * 4;
        const perspective = Math.cos(this.rotation);
        const scaleX = Math.abs(perspective);
        
        ctx.save();
        ctx.translate(this.x, this.y + floatY);
        
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ffff00';
        
        // Coin with 3D rotation effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
        gradient.addColorStop(0, '#ffffcc');
        gradient.addColorStop(0.4, '#ffff00');
        gradient.addColorStop(0.7, '#ffdd00');
        gradient.addColorStop(1, '#cc9900');
        ctx.fillStyle = gradient;
        
        ctx.save();
        ctx.scale(scaleX, 1);
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Outer ring
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Inner detail
        if (scaleX > 0.3) {
            ctx.strokeStyle = '#cc8800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, this.size * 0.7, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
        
        // $ symbol
        if (scaleX > 0.5) {
            ctx.fillStyle = '#885500';
            ctx.font = `bold ${this.size * 1.1}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.save();
            ctx.scale(scaleX, 1);
            ctx.fillText('$', 0, 0);
            ctx.restore();
        }
        
        // Sparkle effect
        if (this.animFrame % 20 < 3) {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#fff';
            ctx.fillRect(-this.size/3, 0, this.size/1.5, 2);
            ctx.fillRect(0, -this.size/3, 2, this.size/1.5);
        }
        
        ctx.restore();
    }
    
    collect() {
        this.dead = true;
        const value = gameState.doublePointsActive ? CONFIG.COIN_VALUE * 2 : CONFIG.COIN_VALUE;
        gameState.coins += 1;
        gameState.score += value;
        createExplosion(this.x, this.y, '#ffff00', 12);
    }
}

class RoadTrap extends Entity {
    constructor(lane, type = 'spikes') {
        const x = getLaneX(lane);
        super(x, -100);
        this.lane = lane;
        this.type = type; // 'spikes', 'block'
        this.width = getRoadBounds().width / CONFIG.LANE_COUNT;
        this.height = type === 'block' ? 150 : 80;
        this.speed = gameState.speed;
        this.animFrame = 0;
        this.damage = type === 'block' ? 40 : 25;
    }
    
    update() {
        this.y += this.speed;
        this.animFrame++;
        
        if (this.y > canvas.height + 150) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.save();
        
        if (this.type === 'block') {
            // Complete lane blockage - RED WARNING
            const flashOn = this.animFrame % 20 < 10;
            
            ctx.fillStyle = flashOn ? '#ff0000' : '#aa0000';
            ctx.shadowBlur = flashOn ? 40 : 20;
            ctx.shadowColor = '#ff0000';
            
            const laneX = getLaneX(this.lane);
            const laneWidth = getRoadBounds().width / CONFIG.LANE_COUNT;
            
            ctx.fillRect(laneX - laneWidth/2, this.y - this.height/2, laneWidth, this.height);
            
            // Warning stripes
            ctx.fillStyle = flashOn ? '#ffff00' : '#ffaa00';
            for (let i = 0; i < 5; i++) {
                const y = this.y - this.height/2 + i * 30;
                ctx.fillRect(laneX - laneWidth/2, y, laneWidth, 10);
            }
            
            // WARNING text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.fillText('BLOCKED', laneX, this.y);
            
        } else {
            // Spike trap
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0055';
            
            const spikeCount = 8;
            const laneX = getLaneX(this.lane);
            const laneWidth = getRoadBounds().width / CONFIG.LANE_COUNT;
            
            for (let i = 0; i < spikeCount; i++) {
                const x = laneX - laneWidth/2 + (laneWidth / spikeCount) * i + laneWidth / (spikeCount * 2);
                const spikeHeight = 25 + Math.sin(this.animFrame * 0.1 + i) * 5;
                
                ctx.fillStyle = '#ff0055';
                ctx.beginPath();
                ctx.moveTo(x, this.y);
                ctx.lineTo(x - 8, this.y + spikeHeight);
                ctx.lineTo(x + 8, this.y + spikeHeight);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#ff0088';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Base
            ctx.fillStyle = '#660022';
            ctx.fillRect(laneX - laneWidth/2, this.y + 25, laneWidth, 15);
        }
        
        ctx.restore();
    }
}

class PowerUp extends Entity {
    constructor(x, y, type) {
        super(x, y);
        this.type = type;
        this.size = 34;
        this.speed = gameState.speed * 0.5;
        this.pulse = 0;
        this.rotation = 0;
    }
    
    update() {
        this.y += this.speed;
        this.pulse += 0.18;
        this.rotation += 0.06;
        
        if (this.y > canvas.height + 100) {
            this.dead = true;
        }
    }
    
    draw() {
        const size = this.size + Math.sin(this.pulse) * 7;
        let color = '#fff';
        let symbol = '';
        
        switch(this.type) {
            case 'weapon':
                color = '#ff00ff';
                symbol = '‚ö°';
                break;
            case 'health':
                color = '#00ff00';
                symbol = '+';
                break;
            case 'shield':
                color = '#00ffff';
                symbol = '‚óÜ';
                break;
            case 'double':
                color = '#ffff00';
                symbol = 'x2';
                break;
            case 'bomb':
                color = '#ff0055';
                symbol = 'üí£';
                break;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        ctx.shadowBlur = 35;
        ctx.shadowColor = color;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.strokeRect(-size/2, -size/2, size, size);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(-size/2 + 4, -size/2 + 4, size - 8, size - 8);
        
        ctx.fillStyle = color;
        ctx.font = `bold ${size * 0.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbol, 0, 0);
        
        ctx.restore();
    }
    
    collect() {
        this.dead = true;
        
        switch(this.type) {
            case 'weapon':
                gameState.weaponIndex = Math.min(CONFIG.WEAPONS.length - 1, gameState.weaponIndex + 1);
                showMessage(`WEAPON UPGRADE!\n${CONFIG.WEAPONS[gameState.weaponIndex].name}`, CONFIG.WEAPONS[gameState.weaponIndex].color);
                break;
            case 'health':
                gameState.health = Math.min(CONFIG.PLAYER_MAX_HEALTH, gameState.health + 30);
                showMessage('HEALTH +30', '#00ff00');
                break;
            case 'shield':
                gameState.shieldActive = true;
                gameState.shieldTime = 500;
                showMessage('SHIELD ACTIVE!', '#00ffff');
                break;
            case 'double':
                gameState.doublePointsActive = true;
                gameState.doublePointsTime = 600;
                showMessage('DOUBLE POINTS!', '#ffff00');
                break;
            case 'bomb':
                enemies.forEach(e => {
                    gameState.score += e.points;
                    createExplosion(e.x, e.y, e.color, 15);
                });
                obstacles.forEach(o => {
                    gameState.score += 200;
                    createExplosion(o.x, o.y, o.color, 15);
                });
                enemies = [];
                obstacles = [];
                gameState.shake = 25;
                showMessage('MEGA BOMB!', '#ff0055');
                break;
        }
        
        gameState.score += 100;
    }
}

class Particle extends Entity {
    constructor(x, y, color, vx, vy) {
        super(x, y);
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = 1.0;
        this.decay = 0.018 + Math.random() * 0.025;
        this.size = 3 + Math.random() * 5;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.15;
        this.life -= this.decay;
        
        if (this.life <= 0) {
            this.dead = true;
        }
    }
    
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 12;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

// Entity arrays
let bullets = [];
let enemyBullets = [];
let enemies = [];
let obstacles = [];
let coins = [];
let powerups = [];
let particles = [];
let roadTraps = [];

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function random(min, max) {
    return Math.random() * (max - min) + min;
}

function randomInt(min, max) {
    return Math.floor(random(min, max + 1));
}

function collideCircle(x1, y1, r1, x2, y2, r2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return (dx * dx + dy * dy) < (r1 + r2) * (r1 + r2);
}

function collideRect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
}

function getRoadBounds() {
    const roadWidth = canvas.width * CONFIG.ROAD_WIDTH;
    const left = (canvas.width - roadWidth) / 2;
    const right = left + roadWidth;
    return { left, right, width: roadWidth };
}

function getLaneX(lane) {
    const road = getRoadBounds();
    const laneWidth = road.width / CONFIG.LANE_COUNT;
    return road.left + laneWidth * lane + laneWidth / 2;
}

function createExplosion(x, y, color, count = 20) {
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 / count) * i + random(-0.2, 0.2);
        const speed = random(2, 10);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        particles.push(new Particle(x, y, color, vx, vy));
    }
}

function showMessage(text, color) {
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.style.color = color;
    msg.style.textShadow = `0 0 25px ${color}, 0 0 50px ${color}`;
    msg.classList.add('show');
    setTimeout(() => msg.classList.remove('show'), 1800);
}

// ============================================================================
// SPAWNING FUNCTIONS
// ============================================================================

function spawnEnemy() {
    const lane = randomInt(0, CONFIG.LANE_COUNT - 1);
    const x = getLaneX(lane);
    
    let typeIndex = 0;
    const rand = Math.random();
    
    // Progressive enemy types based on tier
    if (gameState.currentTier >= 5) {
        // LEGEND: All enemy types including bosses
        if (rand < 0.25) typeIndex = randomInt(0, 1);
        else if (rand < 0.45) typeIndex = randomInt(2, 4);
        else if (rand < 0.7) typeIndex = randomInt(5, 6);
        else if (rand < 0.9) typeIndex = 7;
        else typeIndex = randomInt(8, 9); // Bosses
    } else if (gameState.currentTier >= 4) {
        // MASTER: Heavy units and occasional boss
        if (rand < 0.3) typeIndex = randomInt(0, 2);
        else if (rand < 0.6) typeIndex = randomInt(3, 5);
        else if (rand < 0.85) typeIndex = randomInt(6, 7);
        else typeIndex = 8;
    } else if (gameState.currentTier >= 3) {
        // EXPERT: Tanks and heavy units
        if (rand < 0.4) typeIndex = randomInt(0, 3);
        else if (rand < 0.75) typeIndex = randomInt(4, 5);
        else typeIndex = randomInt(6, 7);
    } else if (gameState.currentTier >= 2) {
        // PRO: Assault units
        if (rand < 0.5) typeIndex = randomInt(0, 2);
        else if (rand < 0.85) typeIndex = randomInt(3, 4);
        else typeIndex = 5;
    } else if (gameState.currentTier >= 1) {
        // STREET: Fighters
        if (rand < 0.6) typeIndex = randomInt(0, 1);
        else if (rand < 0.9) typeIndex = randomInt(2, 3);
        else typeIndex = 4;
    } else {
        // ROOKIE: Easy enemies
        if (rand < 0.7) typeIndex = 0;
        else if (rand < 0.9) typeIndex = 1;
        else typeIndex = 2;
    }
    
    enemies.push(new Enemy(x, -80, typeIndex));
}

function spawnObstacle() {
    const lane = randomInt(0, CONFIG.LANE_COUNT - 1);
    const x = getLaneX(lane);
    obstacles.push(new Obstacle(x, -80));
}

function spawnCoin() {
    const lane = randomInt(0, CONFIG.LANE_COUNT - 1);
    const x = getLaneX(lane);
    coins.push(new Coin(x, -50));
}

function spawnPowerUp() {
    const lane = randomInt(0, CONFIG.LANE_COUNT - 1);
    const x = getLaneX(lane);
    
    const types = ['weapon', 'health', 'shield', 'double', 'bomb'];
    const weights = [0.35, 0.25, 0.2, 0.15, 0.05];
    
    let rand = Math.random();
    let type = types[0];
    
    for (let i = 0; i < types.length; i++) {
        if (rand < weights[i]) {
            type = types[i];
            break;
        }
        rand -= weights[i];
    }
    
    powerups.push(new PowerUp(x, -60, type));
}

function spawnTrap() {
    const lane = randomInt(0, CONFIG.LANE_COUNT - 1);
    const type = Math.random() > 0.6 ? 'block' : 'spikes';
    roadTraps.push(new RoadTrap(lane, type));
}

// ============================================================================
// PLAYER & WEAPONS
// ============================================================================

function fireWeapon() {
    const now = Date.now();
    const weapon = CONFIG.WEAPONS[gameState.weaponIndex];
    
    if (now - gameState.lastFireTime < weapon.fireRate) return;
    
    gameState.lastFireTime = now;
    const px = gameState.playerX;
    const py = gameState.playerY;
    
    switch(weapon.pattern) {
        case "single":
            bullets.push(new Bullet(px, py - 35, 0, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            break;
        case "triple":
            bullets.push(new Bullet(px, py - 35, 0, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px - 20, py - 28, -1, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px + 20, py - 28, 1, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            break;
        case "spread":
            bullets.push(new Bullet(px, py - 35, 0, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px - 15, py - 30, -2, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px + 15, py - 30, 2, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px - 25, py - 25, -4, -CONFIG.BULLET_SPEED * 0.9, gameState.weaponIndex));
            bullets.push(new Bullet(px + 25, py - 25, 4, -CONFIG.BULLET_SPEED * 0.9, gameState.weaponIndex));
            break;
        case "laser":
            bullets.push(new Bullet(px - 8, py - 35, 0, -CONFIG.BULLET_SPEED * 1.3, gameState.weaponIndex));
            bullets.push(new Bullet(px + 8, py - 35, 0, -CONFIG.BULLET_SPEED * 1.3, gameState.weaponIndex));
            break;
        case "plasma":
            bullets.push(new Bullet(px, py - 35, 0, -CONFIG.BULLET_SPEED * 1.1, gameState.weaponIndex));
            bullets.push(new Bullet(px - 18, py - 30, -1.5, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            bullets.push(new Bullet(px + 18, py - 30, 1.5, -CONFIG.BULLET_SPEED, gameState.weaponIndex));
            break;
    }
}

function drawPlayer() {
    const px = gameState.playerX;
    const py = gameState.playerY;
    
    ctx.save();
    ctx.translate(px, py);
    
    const tilt = (gameState.targetX - px) * 0.0018;
    ctx.rotate(tilt);
    
    if (gameState.shieldActive) {
        const shieldPulse = Math.sin(gameState.frame * 0.25) * 0.25 + 0.75;
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 4;
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#00ffff';
        ctx.globalAlpha = shieldPulse;
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    
    const w = CONFIG.PLAYER_WIDTH;
    const h = CONFIG.PLAYER_HEIGHT;
    
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#00ffff';
    
    ctx.fillStyle = '#001528';
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    ctx.moveTo(-w/2.5, h/2);
    ctx.lineTo(-w/3, -h/2.5);
    ctx.lineTo(-w/4, -h/2);
    ctx.lineTo(w/4, -h/2);
    ctx.lineTo(w/3, -h/2.5);
    ctx.lineTo(w/2.5, h/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    const gradient = ctx.createLinearGradient(0, -h/3, 0, 0);
    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
    gradient.addColorStop(1, 'rgba(0, 100, 150, 0.6)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-w/4, -h/3, w/2, h/3);
    
    ctx.fillStyle = '#003050';
    ctx.fillRect(-w/2.5, -h/4, w/8, h/1.5);
    ctx.fillRect(w/2.5 - w/8, -h/4, w/8, h/1.5);
    
    ctx.strokeStyle = '#0088aa';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-w/5, -h/2);
    ctx.lineTo(-w/6, h/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w/5, -h/2);
    ctx.lineTo(w/6, h/2);
    ctx.stroke();
    
    const engineGlow = gameState.frame % 3 < 2 ? '#00ffff' : '#ffffff';
    ctx.fillStyle = engineGlow;
    ctx.shadowBlur = 20;
    
    ctx.fillRect(-w/3, h/2, w/7, 18);
    ctx.fillRect(w/3 - w/7, h/2, w/7, 18);
    
    ctx.fillRect(-w/2.3, h/3, w/12, 10);
    ctx.fillRect(w/2.3 - w/12, h/3, w/12, 10);
    
    const weaponColor = CONFIG.WEAPONS[gameState.weaponIndex].color;
    ctx.fillStyle = weaponColor;
    ctx.shadowColor = weaponColor;
    ctx.shadowBlur = 15;
    
    ctx.fillRect(-w/4 - 2, -h/2.5, 4, 8);
    ctx.fillRect(w/4 - 2, -h/2.5, 4, 8);
    
    ctx.restore();
}

// ============================================================================
// BACKGROUND & RENDERING
// ============================================================================

function drawBackground() {
    const theme = CONFIG.THEMES[gameState.currentTheme];
    
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, theme.colors[0]);
    gradient.addColorStop(0.5, theme.colors[1]);
    gradient.addColorStop(1, theme.colors[2]);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 80; i++) {
        const x = (i * 137 + gameState.frame * 0.5) % canvas.width;
        const y = (i * 241 + gameState.frame * (1 + i % 4)) % canvas.height;
        const size = 1 + (i % 3);
        const alpha = 0.3 + (Math.sin(gameState.frame * 0.05 + i) * 0.3 + 0.4);
        ctx.globalAlpha = alpha;
        ctx.fillRect(x, y, size, size);
    }
    ctx.globalAlpha = 1;
    
    ctx.strokeStyle = theme.accent;
    ctx.globalAlpha = 0.1;
    ctx.lineWidth = 1;
    
    const gridSize = 80;
    const offsetY = (gameState.frame * gameState.speed * 0.5) % gridSize;
    
    for (let y = -gridSize + offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
}

function drawRoad() {
    const road = getRoadBounds();
    const theme = CONFIG.THEMES[gameState.currentTheme];
    
    const roadGradient = ctx.createLinearGradient(road.left, 0, road.right, 0);
    roadGradient.addColorStop(0, 'rgba(10, 10, 30, 0.7)');
    roadGradient.addColorStop(0.5, 'rgba(20, 20, 50, 0.8)');
    roadGradient.addColorStop(1, 'rgba(10, 10, 30, 0.7)');
    
    ctx.fillStyle = roadGradient;
    ctx.fillRect(road.left, 0, road.width, canvas.height);
    
    ctx.strokeStyle = theme.accent;
    ctx.lineWidth = 4;
    ctx.shadowBlur = 15;
    ctx.shadowColor = theme.accent;
    
    ctx.beginPath();
    ctx.moveTo(road.left, 0);
    ctx.lineTo(road.left, canvas.height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(road.right, 0);
    ctx.lineTo(road.right, canvas.height);
    ctx.stroke();
    
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 3;
    ctx.shadowBlur = 5;
    ctx.shadowColor = '#888';
    ctx.setLineDash([25, 25]);
    ctx.lineDashOffset = -(gameState.frame * gameState.speed * 0.8) % 50;
    
    for (let i = 1; i < CONFIG.LANE_COUNT; i++) {
        const x = road.left + (road.width / CONFIG.LANE_COUNT) * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
    
    if (gameState.speed > 8) {
        const intensity = Math.min(1, (gameState.speed - 8) / 12);
        ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.5})`;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 35; i++) {
            const x = road.left + random(0, road.width);
            const y = (gameState.frame * gameState.speed * 3 + i * 50) % canvas.height;
            const length = 40 + random(0, 40);
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + length);
            ctx.stroke();
        }
    }
}

// ============================================================================
// UPDATE & GAME LOGIC
// ============================================================================

function updateDifficulty() {
    gameState.elapsedTime = (Date.now() - gameState.startTime) / 1000;
    
    for (let i = CONFIG.DIFFICULTY_TIERS.length - 1; i >= 0; i--) {
        if (gameState.elapsedTime >= CONFIG.DIFFICULTY_TIERS[i].time) {
            if (gameState.currentTier !== i) {
                gameState.currentTier = i;
                const tier = CONFIG.DIFFICULTY_TIERS[i];
                gameState.speed = tier.speed;
                gameState.aggressiveness = tier.aggressiveness;
                showMessage(`TIER ${i + 1}\n${tier.name}`, '#0ff');
            }
            break;
        }
    }
    
    const themeIndex = Math.floor(gameState.elapsedTime / 20) % CONFIG.THEMES.length;
    if (themeIndex !== gameState.currentTheme) {
        gameState.currentTheme = themeIndex;
        showMessage(CONFIG.THEMES[themeIndex].name, CONFIG.THEMES[themeIndex].accent);
    }
}

function update() {
    if (!gameState.running || gameState.paused) return;
    
    gameState.frame++;
    updateDifficulty();
    
    const tier = CONFIG.DIFFICULTY_TIERS[gameState.currentTier];
    
    gameState.score += Math.floor(gameState.speed * 0.1);
    
    const moveSpeed = CONFIG.PLAYER_SPEED;
    
    if (gameState.moveLeft) gameState.targetX -= moveSpeed;
    if (gameState.moveRight) gameState.targetX += moveSpeed;
    
    const road = getRoadBounds();
    gameState.targetX = Math.max(road.left + 25, Math.min(road.right - 25, gameState.targetX));
    gameState.playerX += (gameState.targetX - gameState.playerX) * 0.18;
    
    if (gameState.firing) {
        fireWeapon();
    }
    
    if (gameState.shieldActive) {
        gameState.shieldTime--;
        if (gameState.shieldTime <= 0) gameState.shieldActive = false;
    }
    
    if (gameState.doublePointsActive) {
        gameState.doublePointsTime--;
        if (gameState.doublePointsTime <= 0) gameState.doublePointsActive = false;
    }
    
    // SPAWNING
    if (gameState.elapsedTime >= CONFIG.SPAWN_DELAY) {
        if (gameState.frame % Math.max(12, Math.floor(tier.enemyRate)) === 0) {
            spawnEnemy();
        }
        
        if (gameState.frame % Math.max(18, Math.floor(tier.coinRate)) === 0) {
            spawnCoin();
        }
        
        if (gameState.frame % Math.max(50, Math.floor(tier.obstacleRate)) === 0 && Math.random() > 0.5) {
            spawnObstacle();
        }
        
        if (gameState.frame % Math.max(80, Math.floor(tier.trapRate)) === 0) {
            spawnTrap();
        }
        
        if (gameState.frame % CONFIG.POWERUP_SPAWN_INTERVAL === 0) {
            spawnPowerUp();
        }
    }
    
    // Update all entities
    bullets.forEach(b => b.update());
    enemyBullets.forEach(b => b.update());
    enemies.forEach(e => e.update());
    obstacles.forEach(o => o.update());
    coins.forEach(c => c.update());
    powerups.forEach(p => p.update());
    particles.forEach(p => p.update());
    roadTraps.forEach(t => t.update());
    
    // Collision: Bullets vs Enemies & Obstacles
    bullets.forEach(bullet => {
        enemies.forEach(enemy => {
            if (!bullet.dead && !enemy.dead) {
                if (collideCircle(bullet.x, bullet.y, 8, enemy.x, enemy.y, enemy.size/2)) {
                    bullet.dead = true;
                    enemy.takeDamage(bullet.weapon.damage);
                }
            }
        });
        
        obstacles.forEach(obstacle => {
            if (!bullet.dead && !obstacle.dead) {
                if (collideRect(bullet.x - 2, bullet.y, 4, 20, 
                    obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, 
                    obstacle.width, obstacle.height)) {
                    bullet.dead = true;
                    obstacle.takeDamage(bullet.weapon.damage);
                }
            }
        });
    });
    
    // Collision: Enemy bullets vs Player
    enemyBullets.forEach(bullet => {
        if (!bullet.dead) {
            if (collideCircle(bullet.x, bullet.y, bullet.width, gameState.playerX, gameState.playerY, 25)) {
                if (!gameState.shieldActive) {
                    gameState.health -= 8;
                    gameState.shake = 10;
                    createExplosion(bullet.x, bullet.y, '#ff0055', 8);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
                bullet.dead = true;
            }
        }
    });
    
    // Collision: Player vs Enemies
    enemies.forEach(enemy => {
        if (!enemy.dead) {
            if (collideCircle(gameState.playerX, gameState.playerY, 25, enemy.x, enemy.y, enemy.size/2)) {
                if (!gameState.shieldActive) {
                    gameState.health -= 15;
                    gameState.shake = 18;
                    createExplosion(enemy.x, enemy.y, enemy.color, 20);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
                enemy.dead = true;
            }
        }
    });
    
    // Collision: Player vs Obstacles
    obstacles.forEach(obstacle => {
        if (!obstacle.dead) {
            if (collideRect(gameState.playerX - CONFIG.PLAYER_WIDTH/2, gameState.playerY - CONFIG.PLAYER_HEIGHT/2,
                CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT,
                obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, 
                obstacle.width, obstacle.height)) {
                if (!gameState.shieldActive) {
                    gameState.health -= 20;
                    gameState.shake = 20;
                    createExplosion(obstacle.x, obstacle.y, obstacle.color, 20);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
                obstacle.dead = true;
            }
        }
    });
    
    // Collision: Player vs Road Traps
    roadTraps.forEach(trap => {
        if (!trap.dead) {
            const laneX = getLaneX(trap.lane);
            const laneWidth = getRoadBounds().width / CONFIG.LANE_COUNT;
            
            if (collideRect(gameState.playerX - CONFIG.PLAYER_WIDTH/2, gameState.playerY - CONFIG.PLAYER_HEIGHT/2,
                CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT,
                laneX - laneWidth/2, trap.y - trap.height/2, 
                laneWidth, trap.height)) {
                if (!gameState.shieldActive) {
                    gameState.health -= trap.damage;
                    gameState.shake = trap.damage;
                    createExplosion(gameState.playerX, gameState.playerY, '#ff0055', 15);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
                trap.dead = true;
            }
        }
    });
    
    // Collision: Player vs Coins
    coins.forEach(coin => {
        if (!coin.dead) {
            if (collideCircle(gameState.playerX, gameState.playerY, 30, coin.x, coin.y, coin.size)) {
                coin.collect();
            }
        }
    });
    
    // Collision: Player vs PowerUps
    powerups.forEach(powerup => {
        if (!powerup.dead) {
            if (collideCircle(gameState.playerX, gameState.playerY, 35, powerup.x, powerup.y, powerup.size)) {
                powerup.collect();
            }
        }
    });
    
    // Remove dead entities
    bullets = bullets.filter(b => !b.dead);
    enemyBullets = enemyBullets.filter(b => !b.dead);
    enemies = enemies.filter(e => !e.dead);
    obstacles = obstacles.filter(o => !o.dead);
    coins = coins.filter(c => !c.dead);
    powerups = powerups.filter(p => !p.dead);
    particles = particles.filter(p => !p.dead);
    roadTraps = roadTraps.filter(t => !t.dead);
    
    updateUI();
}

function draw() {
    ctx.save();
    
    if (gameState.shake > 0) {
        ctx.translate(
            random(-gameState.shake, gameState.shake),
            random(-gameState.shake, gameState.shake)
        );
        gameState.shake *= 0.88;
    }
    
    drawBackground();
    drawRoad();
    
    particles.forEach(p => p.draw());
    roadTraps.forEach(t => t.draw());
    coins.forEach(c => c.draw());
    powerups.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
    enemyBullets.forEach(b => b.draw());
    obstacles.forEach(o => o.draw());
    enemies.forEach(e => e.draw());
    drawPlayer();
    
    ctx.restore();
}

function updateUI() {
    document.getElementById('score').textContent = Math.floor(gameState.score).toString().padStart(6, '0');
    document.getElementById('coins').textContent = gameState.coins;
    
    const minutes = Math.floor(gameState.elapsedTime / 60);
    const seconds = Math.floor(gameState.elapsedTime % 60);
    document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    document.getElementById('health').textContent = `${Math.max(0, gameState.health)}%`;
    document.getElementById('weaponType').textContent = CONFIG.WEAPONS[gameState.weaponIndex].name;
    
    const healthEl = document.getElementById('health');
    if (gameState.health > 60) {
        healthEl.style.color = '#0f0';
        healthEl.style.textShadow = '0 0 12px #0f0, 0 0 24px #0f0';
    } else if (gameState.health > 30) {
        healthEl.style.color = '#ff0';
        healthEl.style.textShadow = '0 0 12px #ff0, 0 0 24px #ff0';
    } else {
        healthEl.style.color = '#f00';
        healthEl.style.textShadow = '0 0 12px #f00, 0 0 24px #f00';
    }
    
    const weaponEl = document.getElementById('weaponType');
    const weaponColor = CONFIG.WEAPONS[gameState.weaponIndex].color;
    weaponEl.style.color = weaponColor;
    weaponEl.style.textShadow = `0 0 12px ${weaponColor}, 0 0 24px ${weaponColor}`;
}

// ============================================================================
// GAME CONTROL
// ============================================================================

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    
    gameState = {
        running: true,
        paused: false,
        muted: false,
        frame: 0,
        startTime: Date.now(),
        elapsedTime: 0,
        score: 0,
        coins: 0,
        health: CONFIG.PLAYER_MAX_HEALTH,
        weaponIndex: 0,
        currentTier: 0,
        currentTheme: 0,
        speed: 4,
        aggressiveness: 0,
        playerX: canvas.width / 2,
        playerY: canvas.height - 110,
        targetX: canvas.width / 2,
        shake: 0,
        shieldActive: false,
        shieldTime: 0,
        doublePointsActive: false,
        doublePointsTime: 0,
        firing: false,
        lastFireTime: 0,
        moveLeft: false,
        moveRight: false
    };
    
    bullets = [];
    enemyBullets = [];
    enemies = [];
    obstacles = [];
    coins = [];
    powerups = [];
    particles = [];
    roadTraps = [];
    
    updateUI();
}

function togglePause() {
    if (!gameState.running) return;
    
    gameState.paused = !gameState.paused;
    const pauseBtn = document.getElementById('pauseBtn');
    
    if (gameState.paused) {
        pauseBtn.textContent = '‚ñ∂';
        pauseBtn.classList.add('active');
        showMessage('PAUSED', '#0ff');
    } else {
        pauseBtn.textContent = '‚è∏';
        pauseBtn.classList.remove('active');
        gameState.startTime = Date.now() - gameState.elapsedTime * 1000;
    }
}

function toggleMute() {
    gameState.muted = !gameState.muted;
    const muteBtn = document.getElementById('muteBtn');
    
    if (gameState.muted) {
        muteBtn.textContent = 'üîá';
        muteBtn.classList.add('active');
    } else {
        muteBtn.textContent = 'üîä';
        muteBtn.classList.remove('active');
    }
}

function gameOver() {
    gameState.running = false;
    gameState.shake = 35;
    
    const finalScore = Math.floor(gameState.score);
    const finalCoins = gameState.coins;
    const timeStr = document.getElementById('time').textContent;
    
    showMessage(`MISSION FAILED\nSCORE: ${finalScore}\nCOINS: ${finalCoins}\nTIME: ${timeStr}`, '#f05');
    
    setTimeout(() => {
        document.getElementById('startScreen').classList.remove('hidden');
    }, 3500);
}

// ============================================================================
// INPUT HANDLING
// ============================================================================

window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        gameState.moveLeft = true;
    }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        gameState.moveRight = true;
    }
    if (e.key === ' ' || e.key === 'Enter') {
        gameState.firing = true;
        e.preventDefault();
    }
    if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
        togglePause();
        e.preventDefault();
    }
    if (e.key === 'm' || e.key === 'M') {
        toggleMute();
    }
});

window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        gameState.moveLeft = false;
    }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        gameState.moveRight = false;
    }
    if (e.key === ' ' || e.key === 'Enter') {
        gameState.firing = false;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (!isMobile && gameState.running) {
        const rect = canvas.getBoundingClientRect();
        gameState.targetX = e.clientX - rect.left;
    }
});

canvas.addEventListener('mousedown', () => {
    if (!isMobile) gameState.firing = true;
});

canvas.addEventListener('mouseup', () => {
    if (!isMobile) gameState.firing = false;
});

if (isMobile) {
    document.getElementById('mobileControls').classList.add('active');
    
    const setupTouch = (id, onStart, onEnd) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => {
            onStart();
            e.preventDefault();
        });
        el.addEventListener('touchend', (e) => {
            onEnd();
            e.preventDefault();
        });
    };
    
    setupTouch('btnLeft', () => gameState.moveLeft = true, () => gameState.moveLeft = false);
    setupTouch('btnRight', () => gameState.moveRight = true, () => gameState.moveRight = false);
    setupTouch('btnFire', () => gameState.firing = true, () => gameState.firing = false);
}

document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('muteBtn').addEventListener('click', toggleMute);

// ============================================================================
// INITIALIZATION
// ============================================================================

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gameState.playerY = canvas.height - 110;
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

document.getElementById('startBtn').addEventListener('click', startGame);
window.addEventListener('resize', resize);

resize();
gameLoop();

</script>
</body>
</html>